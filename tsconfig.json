{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */

    "target": "esnext", // async iterators
    "module": "esnext",

    // Node 프로젝트라면 무조건 "Node" 여야 한다.
    // Node 방식을 쓰지 않을 수 없다.
    "moduleResolution": "Node",

    // 컴파일러가 기본 제공하는 타입셋을 지정한다.
    "lib": ["esnext"],

    // TypeScript 가 import 를 require 로 변환해서 출력할 시절에는
    // esModuleInterop 을 켜서 모듈 방식간 호환성을 올려야 했다.
    // 이 옵션을 켜면 require 한 결과물을 한번 감싼다.

    // 하지만 module: es2015 를 하면 require를 안 쓰고 import 로 출력한다.
    // 이러면 호환성 문제는 Node 가 처리하기 때문에 이 옵션의 의미가 없어졌다.

    // 하지만 allowSyntheticDefaultImports 는 그래도 켜야하는데
    // esModuleInterop 을 켜면 allowSyntheticDefaultImports 가 켜지므로
    // 겸사겸사 esModuleInterop 을 켜는 것이 무난하지 않은가 싶다.
    "esModuleInterop": true,

    // esModuleInterop 을 켤 경우 자동으로 켜진다.
    // CommonJS 모듈에 default 가 없어도 오류를 내지 않는다.
    //"allowSyntheticDefaultImports": true,

    // js 파일이 출력될 디렉토리.
    "outDir": "dist",

    // 소스 파일의 루트를 어디로 볼 것인가를 결정한다.
    // outDir 디렉토리에 사용할 서브 패스에 영향을 준다.
    // rootDir 이 "src"일 경우 src/a.ts -> dist/a.js 가 된다.
    // rootDir 이 "."일 경우 src/a.ts -> dist/src/a.js 가 된다.
    // 보통 "src" 정도를 쓰는데 WebStorm 에서 문제가 생겼다.
    // Run Config 에서 $FileDirPathFromParent(src)$ 매크로가 작동하지 않는다.
    // Jasmine 테스트 런을 편하게 하기위해 할 수 없이 rooDir 을 "." 으로 세팅하고
    // dist/src/.../*.js 를 실행하도록 했다.
    "rootDir": ".",

    // 절대경로 import 는 TypeScript 까진 가능하다.
    // 하지만 번들러를 동원하지 않고는 출력된 js 를 실행시킬 방법이 없다.
    // 그냥 상대경로 import 를 사용하도록 한다.
    // "baseUrl": "./"

    "sourceMap": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
  },
  "include": [
    "src/**/*.ts"
  ],
  "exclude": [
  ]
}
